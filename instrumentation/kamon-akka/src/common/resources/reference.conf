# ================================== #
# Kamon-Akka Reference Configuration #
# ================================== #

kamon.instrumentation.akka {

  # If ask-pattern-timeout-warning is enabled, a WARN level log message will be generated if a Future generated by the
  # "ask" pattern fails with an AskTimeoutException and the log message will contain information depending of the
  # selected strategy. The possible values are:
  #
  #   - off: nothing gets logged.
  #   - lightweight: logs a warning when a timeout is reached using source location.
  #   - heavyweight: logs a warning when a timeout is reached using a stack trace captured at the moment the future was created.
  #
  ask-pattern-timeout-warning = off

  # Automatically creates Actor Groups that contain all actors of the same Class at the same level of the Actor System
  # tree. This will only be applied to actors that are not individually tracked, that are not part of another groups and
  # that match the "auto-grouping" filter below. This allows, for example, to automatically get metrics from anonymous
  # actors without messing with filters and risking cardinality explosions.
  #
  auto-grouping = on

  # Filters control how and if the instrumentation will track the behavior of Akka Actors, Routers, Dispatchers and
  # Actor Groups. All filters have two groups of patterns: includes and excludes; inputs matching at least one of the
  # includes patterns and none of the excludes patterns will be accepted. You can read more about filters on the Kamon
  # documentation: https://kamon.io/docs/latest/core/utilities/
  #
  # The test string for the filters is always starting with the Actor System name, followed by the path to the
  # component being tested. For example, when testing for a "test" actor created at the root of the "akka-example" Actor
  # System, the test string for the filter will be "akka-example/user/test" and, when testing the default dispatcher for
  # that same Actor System the test string for the filters will be "akka-example/akka.actor.default-dispatcher".
  #
  filters {

    # Defines actor groups and the filters that match all actors that should be part of that group. To define a new
    # group, add a configuration like the following:
    #
    #   kamon.instrumentation.akka.filters.groups {
    #     worker-actors {
    #       includes = [ "my-system/user/application/worker-*", "my-system/user/workers/**" ]
    #       excludes = [ ]
    #     }
    #   }
    #
    # The configuration key immediately inside the "groups" path corresponds to the group name and the configuration
    # inside of it should contain a Kamon filter (with the includes/excludes settings).
    groups {

      # Special filter used for auto-grouping. Auto-grouping will only act on actors that are not being explicitly
      # tracked as inidividual actors, do not belong to any other groups and match this filter.
      #
      auto-grouping {
        includes = [ "*/user/**" ]
        excludes = ${?kamon.instrumentation.akka.filters.groups.auto-grouping.excludes} [ ]
      }
    }

    # Decids how Actors are going to be tracked and traced.
    #
    actors {

      # Decides whether the "**" filter can be used for the "track" and "start-trace" filters. Historically, users have
      # beeing using the "**" filters during testing because simplicitly and then go to production with the same filter
      # configuration which usually results in cardinality explosions and/or OOM errors. Since the introduction of auto
      # grouping, the instrumentation will do a much better work at providing metrics out of the box and forbids the use
      # of the "doomsday" wildcard. Enable and use at your own risk.
      #
      doomsday-wildcard = off

      # Decides which actors will have metric tracking enabled. Beware that most of the time what you really need is to
      # track Actor groups instead of individual actors because wildly targetting actors can lead to cardinality issues.
      #
      track {
        includes = ${?kamon.instrumentation.akka.filters.actors.track.includes} [ ]
        excludes = [ "*/system/**", "*/user/IO-**" ]
      }

      # Decides which actors generate Spans for the messages they process, given that there is already an ongoing trace
      # in the Context of the processed message (i.e. there is a Sampled Span in the Context).
      #
      trace {
        includes = [ "*/user/**", "*/system/sharding**" ]
        excludes = ${?kamon.instrumentation.akka.filters.actors.trace.excludes} [ ]
      }

      # Decides which actors generate Spans for the messages they process, even if that requires them to start a new
      # trace. Use with care, starting traces with a broad filter (e.g. using includes = [ "**" ]) can generate a huge
      # amount of traces from scheduled actions and underlying system components that most likely will not improve
      # observability of the system and burry useful traces underneath the noise.
      #
      start-trace {
        includes = ${?kamon.instrumentation.akka.filters.actors.start-trace.includes} [ ]
        excludes = ${?kamon.instrumentation.akka.filters.actors.start-trace.excludes} [ ]
      }
    }

    # Decides which routers should have metric tracking enabled.
    #
    routers {
      includes = [ "**" ]
      excludes = ${?kamon.instrumentation.akka.filters.routers.excludes} [ ]
    }

    # Decides which dispatchers should have metric tracking enabled.
    #
    dispatchers {
      includes = [ "**" ]
      excludes = ${?kamon.instrumentation.akka.filters.dispatchers.excludes} [ ]
    }
  }

  remote {

    # Controls whether tracking of the serialization, deserialization and message size metrics should be tracked for
    # messages going to and coming from a remoting channel.
    track-serialization-metrics = true
  }

  cluster-sharding {
    # Sets the interval at which the Shard metrics (sampling of hosted entities and processed messages across all
    # shards) will be sampled.
    shard-metrics-sample-interval = ${kamon.metric.tick-interval}
  }

  cluster {

    # !! EXPERIMENTAL !!
    #
    # Decides whether to expose the akka.cluster.[members|datacenters] metrics. These metrics are considered
    # experimental and must be explicitly enabled until a future release when they graduate to stable. The name of
    # this setting might change in the future.
    track-cluster-metrics = no

  }
}
# Signals to akka that it should load KamonRemoteInstrument
akka.remote.artery.advanced.instruments += "akka.remote.artery.KamonRemoteInstrument"
kanela.modules {

  akka {
    name = "Akka Instrumentation"
    description = "Provides metrics and message tracing for Akka Actor Systems, Actors, Routers and Dispatchers"
    enabled = yes

    instrumentations = [
      "kamon.instrumentation.akka.instrumentations.EnvelopeInstrumentation",
      "kamon.instrumentation.akka.instrumentations.SystemMessageInstrumentation",
      "kamon.instrumentation.akka.instrumentations.RouterInstrumentation",
      "kamon.instrumentation.akka.instrumentations.ActorInstrumentation",
      "kamon.instrumentation.akka.instrumentations.ActorLoggingInstrumentation",
      "kamon.instrumentation.akka.instrumentations.AskPatternInstrumentation",
      "kamon.instrumentation.akka.instrumentations.EventStreamInstrumentation",
      "kamon.instrumentation.akka.instrumentations.ActorRefInstrumentation",
      "kamon.instrumentation.akka.instrumentations.akka_25.DispatcherInstrumentation",
      "kamon.instrumentation.akka.instrumentations.akka_26.DispatcherInstrumentation",
      "kamon.instrumentation.akka.instrumentations.SchedulerInstrumentation",
      "kamon.instrumentation.akka.instrumentations.ClusterInstrumentation"
    ]

    within = [
      "^akka.dispatch..*",
      "^akka.event..*",
      "^akka.actor..*",
      "^akka.pattern..*",
      "^akka.cluster..*",
      "^akka.routing..*",
      "kamon.instrumentation.akka.instrumentations..*"
    ]
  }

  akka-remote {
    name = "Akka Remote Instrumentation"
    description = "Provides distributed Context propagation and Cluster Metrics for Akka"
    enabled = yes

    instrumentations = [
      "kamon.instrumentation.akka.remote.MessageBufferInstrumentation",
      "kamon.instrumentation.akka.instrumentations.akka_25.remote.RemotingInstrumentation",
      "kamon.instrumentation.akka.instrumentations.akka_26.remote.RemotingInstrumentation"
    ]

    within = [
      "akka.dispatch..*",
      "akka.util..*",
      "akka.remote..*",
      "akka.actor..*",
      "akka.cluster..*",
      "akka.serialization..*"
    ]
  }

  akka-remote-sharding {
    name = "Akka Remote Cluster Sharding Monitoring"
    description = "Provides cluster sharding metrics for Akka"
    enabled = yes

    instrumentations = [
      "kamon.instrumentation.akka.remote.ShardingInstrumentation"
    ]

    within = [
      "akka.dispatch..*",
      "akka.util..*",
      "akka.remote..*",
      "akka.actor..*"
      "akka.cluster..*"
      "akka.serialization..*"
    ]
  }
}
